#include "arduino_secrets.h"
#include <DallasTemperature.h>
#include <OneWire.h>
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/d44d2d68-e458-4e0e-a5b9-9639b9a9844e 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String teaType;
  float ambient_temperature;
  float optimal_temperature;
  float water_temperature;
  int cooling_time;
  bool waterReady;
  CloudTime ready_time;
  CloudTime start_time;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

// Data wire is plugged into port 12 on the Arduino
#define ONE_WIRE_BUS 12

#define RED_LED_PIN 46
#define GREEN_LED_PIN 0

// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);

// Pass our oneWire reference to Dallas Temperature. 
DallasTemperature sensors(&oneWire);

// arrays to hold device address
DeviceAddress insideThermometer;

//local values to hold temperature
float waterTempLocal;
float coolingConstant = 0.000372;
float coolingtime_insecond;

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  pinMode(RED_LED_PIN, OUTPUT);
  pinMode(GREEN_LED_PIN, OUTPUT);
  
  // locate devices on the bus
  Serial.print("Locating devices...");
  sensors.begin();
  Serial.print("Found ");
  Serial.print(sensors.getDeviceCount(), DEC);
  Serial.println(" devices.");

  // Assign address manually. The addresses below will beed to be changed
  // to valid device addresses on your bus. Device address can be retrieved
  // by using either oneWire.search(deviceAddress) or individually via
  // sensors.getAddress(deviceAddress, index)
  // Note that you will need to use your specific address here
  //insideThermometer = { 0x28, 0x1D, 0x39, 0x31, 0x2, 0x0, 0x0, 0xF0 };

  // Method 1:
  // Search for devices on the bus and assign based on an index. Ideally,
  // you would do this to initially discover addresses on the bus and then 
  // use those addresses and manually assign them (see above) once you know 
  // the devices on your bus (and assuming they don't change).
  if (!sensors.getAddress(insideThermometer, 0)) Serial.println("Unable to find address for Device 0"); 
  
  // method 2: search()
  // search() looks for the next device. Returns 1 if a new address has been
  // returned. A zero might mean that the bus is shorted, there are no devices, 
  // or you have already retrieved all of them. It might be a good idea to 
  // check the CRC to make sure you didn't get garbage. The order is 
  // deterministic. You will always get the same devices in the same order
  //
  // Must be called before search()
  //oneWire.reset_search();
  // assigns the first address found to insideThermometer
  //if (!oneWire.search(insideThermometer)) Serial.println("Unable to find address for insideThermometer");

  // show the addresses we found on the bus
  Serial.print("Device 0 Address: ");
  printAddress(insideThermometer);
  Serial.println();

  // set the resolution to 9 bit (Each Dallas/Maxim device is capable of several different resolutions)
  sensors.setResolution(insideThermometer, 9);
 
  Serial.print("Device 0 Resolution: ");
  Serial.print(sensors.getResolution(insideThermometer), DEC); 
  Serial.println();
  
  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // Set tea type to refresh and not trigger alarm
  teaType = 'refresh';

  digitalWrite(RED_LED_PIN, LOW);
  digitalWrite(GREEN_LED_PIN, LOW);
}

float calculateCoolingTime(float T0, float Ta, float Tf, float k) {
  if (Tf >= T0) {
    return 0.0;  // No cooling needed
  }
  float ratio = (Tf - Ta) / (T0 - Ta);
  if (ratio <= 0) {
    return -1.0;  // Invalid case, target temperature can't be reached
  }
  return -log(ratio) / k;
}

// function to print the temperature for a device
void printTemperature(DeviceAddress deviceAddress)
{
  // method 1 - slower
  //Serial.print("Temp C: ");
  //Serial.print(sensors.getTempC(deviceAddress));
  //Serial.print(" Temp F: ");
  //Serial.print(sensors.getTempF(deviceAddress)); // Makes a second call to getTempC and then converts to Fahrenheit

  // method 2 - faster
  float tempC = sensors.getTempC(deviceAddress);
  if(tempC == DEVICE_DISCONNECTED_C) 
  {
    Serial.println("Error: Could not read temperature data");
    return;
  }
  Serial.print("Temp C: ");
  Serial.print(tempC);
  Serial.print(" Temp F: ");
  Serial.println(DallasTemperature::toFahrenheit(tempC)); // Converts tempC to Fahrenheit

  waterTempLocal = tempC;
}

void loop() {
  ArduinoCloud.update();
  // Your code here 
  
  delay(2000);
  // call sensors.requestTemperatures() to issue a global temperature 
  // request to all devices on the bus
  Serial.print("Requesting temperatures...");
  sensors.requestTemperatures(); // Send the command to get temperatures
  Serial.println("DONE");
  
  // It responds almost immediately. Let's print out the data
  printTemperature(insideThermometer); // Use a simple function to print out the data

  water_temperature = waterTempLocal;
  //calaulate cooling time
  Serial.print(ambient_temperature);
  coolingtime_insecond = calculateCoolingTime(water_temperature, ambient_temperature, optimal_temperature, coolingConstant);
  cooling_time = round(coolingtime_insecond / 60); 

  if (cooling_time >= 0) {
    Serial.print("Estimated Cooling Time: ");
    Serial.print(cooling_time);
    Serial.println(" minutes");
  } else {
    Serial.println("Target temperature reached.");
  }

  if (water_temperature <= optimal_temperature){
    Serial.print("Water Ready");
    ready_time = ArduinoCloud.getLocalTime();
    waterReady = true;
    digitalWrite(GREEN_LED_PIN, HIGH);  // Turn ON Green LED
    delay(1000);
    digitalWrite(RED_LED_PIN, LOW);     // Turn OFF Red LED
    delay(1000);
  } else {
    waterReady = false;
    digitalWrite(GREEN_LED_PIN, LOW);   // Turn OFF Green LED
    delay(1000);
    digitalWrite(RED_LED_PIN, HIGH);    // Turn ON Red LED
    delay(1000);
  }
}

// function to print a device address
void printAddress(DeviceAddress deviceAddress)
{
  for (uint8_t i = 0; i < 8; i++)
  {
    if (deviceAddress[i] < 16) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
  }
}

/*
  Since WaterTemperature is READ_WRITE variable, onWaterTemperatureChange() is
  executed every time a new value is received from IoT Cloud.
*/

void onTeaTypeChange(){
  Serial.print("New tea type: ");
  Serial.println(teaType);
  updateOptimalTemperature();
  start_time = ArduinoCloud.getLocalTime();
}

void onWaterTemperatureChange()  {
  // Add your code here to act upon WaterTemperature change
}




/*
  Since WaterReady is READ_WRITE variable, onWaterReadyChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onWaterReadyChange()  {
  // Add your code here to act upon WaterReady change
}

/*
  Since OptimalTemperature is READ_WRITE variable, onOptimalTemperatureChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onOptimalTemperatureChange()  {
  // Add your code here to act upon OptimalTemperature change
}

/*
  Since TeaType is READ_WRITE variable, onTeaTypeChange() is
  executed every time a new value is received from IoT Cloud.
*/
void updateOptimalTemperature()  {
  // Add your code here to act upon TeaType change
  waterReady = false;
  if (teaType == "green"){
    optimal_temperature = 80;
  }else if (teaType == "flower"){
    optimal_temperature = 98;
  }else if (teaType == "black"){
    optimal_temperature = 90;
  }else if (teaType == "jasmine"){
    optimal_temperature = 65;
  }else if (teaType == "refresh"){
    optimal_temperature = -100; 
  }
  Serial.print("Optimal Temperature set to: ");
  Serial.print(optimal_temperature);
  Serial.println("°C, ");
  Serial.println(teaType);
}

/*
  Since AmbientTemperature is READ_WRITE variable, onAmbientTemperatureChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onAmbientTemperatureChange()  {
  // Add your code here to act upon AmbientTemperature change
}

/*
  Since CoolingTime is READ_WRITE variable, onCoolingTimeChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onCoolingTimeChange()  {
  // Add your code here to act upon CoolingTime change
}

/*
  Since ReadyTime is READ_WRITE variable, onReadyTimeChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onReadyTimeChange()  {
  // Add your code here to act upon ReadyTime change
}
/*
  Since StartTime is READ_WRITE variable, onStartTimeChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onStartTimeChange()  {
  // Add your code here to act upon StartTime change
}